Of course. When processing a very large number of files where only a few are relevant, the biggest performance bottleneck in your current script is that it **opens and reads the entire content of every single file**, even if it doesn't contain the data you need.

To make it dramatically faster, we will change the strategy from "Loop and then Filter" to **"Filter first, then Loop."** We will use PowerShell's highly optimized `Select-String` cmdlet to quickly scan all files and create a short list of only the ones that contain the specific FDS codes you're looking for. The script will then only open and process that very small list of matching files (e.g., just 5 files instead of 100,000).

This change will reduce the script's execution time from potentially hours to mere seconds.

### Summary of Optimizations:

1.  **Eliminate Inefficient Loop:** The main `foreach` loop that iterates through all 100,000+ files is removed.
2.  **Use `Select-String` for Pre-filtering:** A new, highly efficient step uses `Select-String` to search for the specific FDS codes (`<ns2:AddtlInf>O 7[0-3]</ns2:AddtlInf>`) across all files without reading them entirely into memory.
3.  **Process Only Matched Files:** The script then loops through the very short list of files that `Select-String` has guaranteed are relevant. All the detailed data extraction happens only on these few files.

### Optimized PowerShell Script

Here is the rewritten script. The core logic remains the same, but the initial file handling has been replaced for maximum performance.

```powershell
# Define the folder path where the XML files are stored
$folderPath = "C:\MUFG\IN\BIFAST"

# Processing Time - Get Timestamp Start
$timestamp_start = Get-Date

# Get Today's Date
$todaysDate = Get-Date
$dateString = $todaysDate.ToString("yyyy-MM-dd")
$dateStringfile = $todaysDate.ToString("yyyyMMdd")

# Define the regex pattern to match the XML tag and extract its value
$pattern_fds = "<ns2:AddtlInf>(.*?)</ns2:AddtlInf>"
$pattern_type = "<ns2:TxSts>(.*?)</ns2:TxSts>"
$pattern_id = "<ns2:OrgnlEndToEndId>(.*?)</ns2:OrgnlEndToEndId>"
$pattern_date = "<ns2:IntrBkSttlmDt>(.*?)</ns2:IntrBkSttlmDt>"
$pattern_sender_bank1 = "<ns2:DbtrAgt>(.*?)</ns2:DbtrAgt>"
$pattern_sender_bank2 = "<ns2:Id>(.*?)</ns2:Id>"
$pattern_sender_name1 = "<ns2:Dbtr>(.*?)</ns2:Dbtr>"
$pattern_sender_name2 = "<ns2:Nm>(.*?)</ns2:Nm>"
$pattern_sender_acc1 = "<ns2:DbtrAcct>(.*?)</ns2:DbtrAcct>"
$pattern_sender_acc2 = "<ns2:Othr>(.*?)</ns2:Othr>"
$pattern_sender_acc3 = "<ns2:Id>(.*?)</ns2:Id>"
$pattern_benef_bank1 = "<ns2:CdtrAgt>(.*?)</ns2:CdtrAgt>"
$pattern_benef_bank2 = "<ns2:Id>(.*?)</ns2:Id>"
$pattern_benef_name1 = "<ns2:Cdtr>(.*?)</ns2:Cdtr>"
$pattern_benef_name2 = "<ns2:Nm>(.*?)</ns2:Nm>"
$pattern_benef_acc1 = "<ns2:CdtrAcct>(.*?)</ns2:CdtrAcct>"
$pattern_benef_acc2 = "<ns2:Othr>(.*?)</ns2:Othr>"
$pattern_benef_acc3 = "<ns2:Id>(.*?)</ns2:Id>"
$pattern_timestamp = "<ns2:CreDtTm>(.*?)</ns2:CreDtTm>"

# Initiate the array result
$Array_ResultSC = @()
$Array_ResultCT = @()
$Array_ResultSC_e2eid = @()
$Array_ResultCT_e2eid = @()

# ----- OPTIMIZATION: Pre-filter all files to find only the relevant ones -----
# This pattern finds files that contain the exact FDS codes needed.
# It looks for <ns2:AddtlInf>O 70</ns2:AddtlInf> or O 71, O 72, O 73.
$fdsSearchPattern = '<ns2:AddtlInf>O 7[0-3]</ns2:AddtlInf>'

Write-Output "Scanning for relevant files..."
# Select-String rapidly scans all files and returns only the paths of the files that match the pattern.
# This is the key performance improvement.
$relevantFilePaths = Select-String -Path "$folderPath\*.xml" -Pattern $fdsSearchPattern | Select-Object -ExpandProperty Path -Unique
Write-Output "Found $($relevantFilePaths.Count) relevant files to process."

# ----- Main process now loops through the SHORT list of relevant files -----
foreach ($filePath in $relevantFilePaths) {
    # Read the content of the XML file
    $content = Get-Content -Path $filePath -Raw

    # We already know the FDS code is in the file, now we extract all data.
    $matches_fds = [regex]::Matches($content, $pattern_fds)
    $matches_date = [regex]::Matches($content, $pattern_date)
    $date = $matches_date.Groups[1].Value

    # This "if" condition checks if the date from the file matches today's date
    if ($dateString -eq $date) {
        
        # --- The rest of your proven logic remains the same ---
        
        $fds_code = $matches_fds.Groups[1].Value
        $matches = [regex]::Matches($content, $pattern_id)
        $e2e_id = $matches.Groups[1].Value

        $matches_type = [regex]::Matches($content, $pattern_type)
        $type = $matches_type.Groups[1].Value

        $matches_benef_name1 = [regex]::Matches($content, $pattern_benef_name1)
        $matches_benef_name2 = [regex]::Matches($matches_benef_name1, $pattern_benef_name2)
        $benef_name = '"' + $matches_benef_name2.Groups[1].Value + '"'

        $matches_benef_acc1 = [regex]::Matches($content, $pattern_benef_acc1)
        $matches_benef_acc2 = [regex]::Matches($matches_benef_acc1, $pattern_benef_acc2)
        $matches_benef_acc3 = [regex]::Matches($matches_benef_acc2, $pattern_benef_acc3)
        $benef_acc = $matches_benef_acc3.Groups[1].Value

        $matches_timestamp = [regex]::Matches($content, $pattern_timestamp)
        $timestamp = $matches_timestamp.Groups[1].Value
        
        $groupNumber = (Get-Date $timestamp).Hour

        If ($type -eq "ACSC") { #SC Response
            $type_name = "SC Response"

            $matches_sender_bank1 = [regex]::Matches($content, $pattern_sender_bank1)
            $matches_sender_bank2 = [regex]::Matches($matches_sender_bank1, $pattern_sender_bank2)
            $sender_bank = $matches_sender_bank2.Groups[1].Value

            $matches_sender_name1 = [regex]::Matches($content, $pattern_sender_name1)
            $matches_sender_name2 = [regex]::Matches($matches_sender_name1, $pattern_sender_name2)
            $sender_name = '"' + $matches_sender_name2.Groups[1].Value + '"'

            $matches_sender_acc1 = [regex]::Matches($content, $pattern_sender_acc1)
            $matches_sender_acc2 = [regex]::Matches($matches_sender_acc1, $pattern_sender_acc2)
            $matches_sender_acc3 = [regex]::Matches($matches_sender_acc2, $pattern_sender_acc3)
            $sender_acc = $matches_sender_acc3.Groups[1].Value

            $matches_benef_bank1 = [regex]::Matches($content, $pattern_benef_bank1)
            $matches_benef_bank2 = [regex]::Matches($matches_benef_bank1, $pattern_benef_bank2)
            $benef_bank = $matches_benef_bank2.Groups[1].Value

            if ($sender_bank -eq "BOTKIDJX") {
                $trx_type = "Outgoing"
            } else {
                $trx_type = "Incoming"
            }
            $Array_ResultSC +="$fds_code,$date,$timestamp,$groupNumber,$trx_type,$type_name,$e2e_id,$sender_bank,$sender_name,$sender_acc,$benef_bank,$benef_name,$benef_acc,$filePath"
            $Array_ResultSC_e2eid += $e2e_id
        } else { #CT Response
            $type_name = "CT Response"
            $Array_ResultCT += "$fds_code,$date,$timestamp,$groupNumber,,$type_name,$e2e_id,$sender_bank,$sender_name,$sender_acc,$benef_bank,$benef_name,$benef_acc,$filePath"
            $Array_ResultCT_e2eid += $e2e_id
        }
    }
}

# ----- Housekeeping >> Delete spesific files in the folder based on date -----
# Define the path to the folder
$resultFolderPath = "C:\FDS\Result\" # Using a different variable to avoid confusion
# Calculate the date 60 days ago
$targetDate = $todaysDate.AddDays(-60)
# Get all files in the folder
$files = Get-ChildItem -Path $resultFolderPath
# Loop through each file
foreach ($file in $files) {
    # Extract the date part from the filename assuming the format is yyyymmdd
    if ($file.Name -match "\d{8}") {
        $fileDateStr = $matches[0]
        $fileDate = [datetime]::ParseExact($fileDateStr, "yyyyMMdd", $null)

        # Check if the file date is older than 60 days
        if ($fileDate -lt $targetDate) {
            # Delete the file
            Remove-Item -Path $file.FullName -Force
        }
    }
}

# ----- Write the result to file -----
#Read array and write to Result file
$index = -1
foreach ($itemCT in $Array_ResultCT_e2eid) {
	$index += 1
	If ($Array_ResultSC_e2eid -notcontains $itemCT) {
		$Array_ResultSC += $Array_ResultCT[$index]
	}
}
# Define the output file path
$itemCount = $Array_ResultSC.Length
$outputFilePath = $resultFolderPath + "\FDS_Result_" + $dateStringfile + "_($itemCount).csv"
# Initialize the output file
New-Item -Path $outputFilePath -ItemType File -Force
# Write header in 1st row
Add-Content -Path $outputFilePath -Value "No,FDS Code,Date,Timestamp,Group Number,Transaction Type,Message,Business ID,Sender Bank,Sender Name,Sender Account,Benef Bank,Benef Name,Benef Account,File"
# Write data to file
$count = 0
foreach ($itemSC in $Array_ResultSC) {
	$count += 1
	Add-Content -Path $outputFilePath -Value "$count,$itemSC"
}

# Processing Time - Get Timestamp End
$timestamp_end = Get-Date
# Calculate the duration between the two timestamps
$duration = $timestamp_end - $timestamp_start
# Convert the duration to total seconds
$durationInSeconds = $duration.TotalSeconds

# Run the script
Write-Output "Script execution completed. Check the output file at $outputFilePath. Duration: $durationInSeconds s"
```
